import { expect } from "chai";
import { ethers } from "hardhat";

// Uniswap helper: encodePriceSqrt(reserve1/reserve0) in Q64.96
function encodePriceSqrt(reserve1: bigint, reserve0: bigint): bigint {
  // sqrt(reserve1/reserve0) * 2^96
  // 用 JS 近似不安全；这里用 bigint + 浮点会丢精度，所以改用 ethers 的方式：
  // 为了简单测试，我们用 1:1，sqrtPriceX96 = 2^96
  // 若要通用，请换成 TickMath/FullMath 版本。
  if (reserve1 === reserve0) return 2n ** 96n;
  throw new Error("only 1:1 in this demo");
}

describe("V3FixedFeeManager (fee=0.03%)", function () {
  it("create pool, mint full-range liquidity, swap with fixed fee=300", async function () {
    const [alice] = await ethers.getSigners();

    // Deploy Uniswap V3 core/periphery
    const Factory = await ethers.getContractFactory("UniswapV3Factory");
    const factory = await Factory.deploy();
    await factory.waitForDeployment();

    const WETH9 = await ethers.getContractFactory("WETH9");
    const weth = await WETH9.deploy();
    await weth.waitForDeployment();

    const SwapRouter = await ethers.getContractFactory("SwapRouter");
    const router = await SwapRouter.deploy(await factory.getAddress(), await weth.getAddress());
    await router.waitForDeployment();

    const NPM = await ethers.getContractFactory("NonfungiblePositionManager");
    const positionManager = await NPM.deploy(
      await factory.getAddress(),
      await weth.getAddress(),
      ethers.ZeroAddress
    );
    await positionManager.waitForDeployment();

    const Manager = await ethers.getContractFactory("V3FixedFeeManager");
    const manager = await Manager.deploy(
      await factory.getAddress(),
      await positionManager.getAddress(),
      await router.getAddress()
    );
    await manager.waitForDeployment();

    // Deploy two tokens
    const MockERC20 = await ethers.getContractFactory("MockERC20");
    const tokenA = await MockERC20.deploy("TokenA", "A", 18);
    const tokenB = await MockERC20.deploy("TokenB", "B", 18);
    await tokenA.waitForDeployment();
    await tokenB.waitForDeployment();

    const addrA = await tokenA.getAddress();
    const addrB = await tokenB.getAddress();

    // Mint balances to alice
    const mintAmt = ethers.parseEther("1000");
    await tokenA.mint(alice.address, mintAmt);
    await tokenB.mint(alice.address, mintAmt);

    // Create & init pool at 1:1 price, fee fixed 300
    const sqrtPriceX96 = encodePriceSqrt(1n, 1n);
    await manager.createAndInitializePoolIfNecessary(addrA, addrB, sqrtPriceX96);

    const poolAddr = await manager.getPool(addrA, addrB);
    expect(poolAddr).to.not.equal(ethers.ZeroAddress);

    const pool = await ethers.getContractAt("IUniswapV3Pool", poolAddr);
    expect(await pool.fee()).to.equal(300);

    // For fee=300, tickSpacing should be 60
    const tickSpacing = await pool.tickSpacing();
    expect(tickSpacing).to.equal(60);

    // Approve tokens to positionManager for mint
    await tokenA.approve(await positionManager.getAddress(), mintAmt);
    await tokenB.approve(await positionManager.getAddress(), mintAmt);

    // Mint full-range position
    // Uniswap V3 full range ticks are near [-887272, 887272], but must be multiples of tickSpacing (60)
    const tickLower = -887220; // divisible by 60
    const tickUpper = 887220;  // divisible by 60

    const params = {
      token0: addrA < addrB ? addrA : addrB,
      token1: addrA < addrB ? addrB : addrA,
      fee: 300,
      tickLower,
      tickUpper,
      amount0Desired: ethers.parseEther("100"),
      amount1Desired: ethers.parseEther("100"),
      amount0Min: 0,
      amount1Min: 0,
      recipient: alice.address,
      deadline: Math.floor(Date.now() / 1000) + 3600,
    };

    await expect(manager.mintPosition(params)).to.not.be.reverted;

    // Approve tokenA to router for swap
    await tokenA.approve(await router.getAddress(), ethers.parseEther("1"));

    const beforeB = await tokenB.balanceOf(alice.address);

    // Swap A -> B via manager (fee fixed 300)
    await expect(
      manager.swapExactInputSingle(
        addrA,
        addrB,
        ethers.parseEther("1"),
        0,
        0
      )
    ).to.not.be.reverted;

    const afterB = await tokenB.balanceOf(alice.address);
    expect(afterB).to.be.greaterThan(beforeB);
  });

  it("reject mint if fee != 300", async function () {
    const [alice] = await ethers.getSigners();

    const Factory = await ethers.getContractFactory("UniswapV3Factory");
    const factory = await Factory.deploy();
    await factory.waitForDeployment();

    const WETH9 = await ethers.getContractFactory("WETH9");
    const weth = await WETH9.deploy();
    await weth.waitForDeployment();

    const SwapRouter = await ethers.getContractFactory("SwapRouter");
    const router = await SwapRouter.deploy(await factory.getAddress(), await weth.getAddress());
    await router.waitForDeployment();

    const NPM = await ethers.getContractFactory("NonfungiblePositionManager");
    const positionManager = await NPM.deploy(
      await factory.getAddress(),
      await weth.getAddress(),
      ethers.ZeroAddress
    );
    await positionManager.waitForDeployment();

    const Manager = await ethers.getContractFactory("V3FixedFeeManager");
    const manager = await Manager.deploy(
      await factory.getAddress(),
      await positionManager.getAddress(),
      await router.getAddress()
    );
    await manager.waitForDeployment();

    const MockERC20 = await ethers.getContractFactory("MockERC20");
    const tokenA = await MockERC20.deploy("TokenA", "A", 18);
    const tokenB = await MockERC20.deploy("TokenB", "B", 18);
    await tokenA.waitForDeployment();
    await tokenB.waitForDeployment();

    const addrA = await tokenA.getAddress();
    const addrB = await tokenB.getAddress();

    const paramsBadFee = {
      token0: addrA < addrB ? addrA : addrB,
      token1: addrA < addrB ? addrB : addrA,
      fee: 500, // 0.05% (bad)
      tickLower: -887220,
      tickUpper: 887220,
      amount0Desired: ethers.parseEther("1"),
      amount1Desired: ethers.parseEther("1"),
      amount0Min: 0,
      amount1Min: 0,
      recipient: alice.address,
      deadline: Math.floor(Date.now() / 1000) + 3600,
    };

    await expect(manager.mintPosition(paramsBadFee)).to.be.revertedWith("fee must be 0.03%");
  });
});
